
from numpy import array, meshgrid, linspace
import matplotlib.pyplot as plt
from matplotlib.cm import get_cmap
from inference.pdf_tools import GaussianKDE, KDE2D, sample_hdi


def matrix_plot(samples, labels = None, show = True, reference = None, filename = None,
                contour = True, colormap = 'viridis', show_ticks = None):
    """
    Construct a 'matrix plot' for a set of variables which shows all possible
    1D and 2D marginal distributions.

    :param samples: \
        A list of array-like objects containing the samples for each variable.

    :keyword labels: \
        A list of strings to be used as axis labels for each parameter being plotted.

    :keyword bool show: \
        Sets whether the plot is displayed.

    :keyword reference: \
        A list of reference values for each parameter which will be over-plotted.

    :keyword str filename: \
        File path to which the matrix plot will be saved (if specified).

    :keyword bool contour: \
        Specifies that 2D marginal distributions are generated by contouring a
        kernel density estimate, rather than the default behaviour of hexagonal
        binning.

    :keyword bool show_ticks: \
        By default, axis ticks are only shown when plotting less than 6 variables.
        This behaviour can be overridden for any number of parameters by setting
        show_ticks to either True or False.
    """

    N_par = len(samples)
    if labels is None:
        labels = ['param ' + str(i) for i in range(N_par)]
    else:
        if len(labels) != N_par:
            raise ValueError('number of labels must match number of plotted parameters')

    if reference is not None:
        if len(reference) != N_par:
            raise ValueError('number of reference values must match number of plotted parameters')
    # by default, we suppress axis ticks if there are 6 parameters or more to keep things tidy
    if show_ticks is None:
        show_ticks = N_par < 6

    L = 200
    cmap = get_cmap(colormap)

    axis_limits = []
    axis_arrays = []
    for sample in samples:
        # get the 98% HDI to calculate plot limits
        lwr, upr = sample_hdi(sample, fraction = 0.98, force_single = True)
        # store the limits and axis array
        axis_limits.append([lwr-(upr-lwr)*0.3, upr+(upr-lwr)*0.3])
        axis_arrays.append(linspace(lwr-(upr-lwr)*0.35, upr+(upr-lwr)*0.35, L))

    fig = plt.figure(figsize = (8,8))
    # build a lower-triangular indices list in diagonal-striped order
    inds_list = [(N_par-1, 0)]  # start with bottom-left corner
    for k in range(1, N_par):
        inds_list.extend([(N_par-1-i, k-i) for i in range(k+1)])

    # now create a dictionary of axis objects with correct sharing
    axes = {}
    for tup in inds_list:
        i, j = tup
        x_share = None
        y_share = None

        if (i < N_par - 1):
            x_share = axes[(N_par - 1, j)]

        if (j > 0) and (i != j):  # diagonal doesnt share y-axis
            y_share = axes[(i, 0)]

        axes[tup] = plt.subplot2grid((N_par, N_par), (i, j), sharex = x_share, sharey = y_share)

    # now loop over grid and plot
    for tup in inds_list:
        i, j = tup
        ax = axes[tup]
        # are we on the diagonal?
        if i == j:
            sample = samples[i]
            pdf = GaussianKDE(sample)
            estimate = array( pdf(axis_arrays[i]) )
            ax.plot(axis_arrays[i], 0.95*(estimate/estimate.max()), lw = 2, color = 'C0')
            if reference is not None:
                ax.plot([reference[i], reference[i]], [0, 1], lw = 1.5, ls = 'dashed', color = 'red')
            ax.set_ylim([0, 1])
        else:
            x = samples[j]
            y = samples[i]

            # plot 2D marginals either by 2D KDE or hexagonal binning
            if contour:
                pdf = KDE2D(x = x, y = y)
                x_ax = axis_arrays[j][::4]
                y_ax = axis_arrays[i][::4]
                X, Y = meshgrid(x_ax, y_ax)
                prob = array(pdf(X.flatten(), Y.flatten())).reshape([L//4, L//4])
                ax.contour(X, Y, prob, 20, cmap = cmap, linewidths = 1.5)
            else:
                ax.set_facecolor(cmap(0))
                ax.hexbin(x,y,gridsize = 30)

            # plot any reference points if given
            if reference is not None:
                ax.plot(reference[j], reference[i], marker = 'o', markersize = 7,
                        markerfacecolor = 'none', markeredgecolor = 'white', markeredgewidth = 3.5)
                ax.plot(reference[j], reference[i], marker = 'o', markersize = 7,
                        markerfacecolor = 'none', markeredgecolor = 'red', markeredgewidth = 2)

        # assign axis labels
        if i == N_par - 1: ax.set_xlabel(labels[j])
        if j == 0 and i != 0: ax.set_ylabel(labels[i])
        # impose x-limits on bottom row
        if i == N_par - 1: ax.set_xlim(axis_limits[j])
        # impose y-limits on left column, except the top-left corner
        if j == 0 and i != 0: ax.set_ylim(axis_limits[i])

        if show_ticks: # set up ticks for the edge plots if they are to be shown
            # hide x-tick labels for plots not on the bottom row
            if (i < N_par - 1): plt.setp(ax.get_xticklabels(), visible=False)
            # hide y-tick labels for plots not in the left column
            if j > 0: plt.setp(ax.get_yticklabels(), visible = False)
            # remove all y-ticks for 1D marginal plots on the diagonal
            if i == j: ax.set_yticks([])
        else: # else remove all ticks from all axes
            ax.set_xticks([])
            ax.set_yticks([])

    # set the plot spacing
    fig.tight_layout()
    fig.subplots_adjust(wspace = 0., hspace = 0.)
    # save/show the figure if required
    if filename is not None: plt.savefig(filename)
    if show:
        plt.show()
    else:
        fig.clear()
        plt.close(fig)